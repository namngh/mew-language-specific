# Mew Language Specific

Authors: Nguyễn Hoàng Nam
Inspiration: Elixir

## Module

Each file is a module with the name generated by compiler following the rule:

- Combine name of directory to in the path to file
- Name of directory write in camel case
- Seperate by dot

Ex:

```
config.mew
lib
|_ controllers
  |_ customer_controller.mew
```

Then the name of module in file customer_controller.mew is `Controllers.CustomerController`.

Name of module can change in config.mew (Not defined yet)

## Function

Function much define inside module so that function can be called by their module. Function start
with `fn` then their name and params part inside parenthesis.

Ex:

```
// lib/utils/validation.mew
fn min(value: int) -> bool:
    value > 18
end

fn max(value: int) -> bool:
    value < 100
end

fn validate(None) -> bool:
    False
end

fn validate(value: int) -> bool:
    min(value) & max(value)
end
```

```
// lib/controllers/customer_controller.mew
fn put(conn: HTTP.Connection, _params) -> {:ok | :error, any}:
    conn
    |> Map.get("body", {})
    |> Map.get("age")
    |> Utils.Validation.validate()
    |> case:
        True -> {:ok, {"success": True}}
        _ -> {:ok, {"success": False}}
    end
end
```

### Anonymous function

Anonymous function is function without name, these much define inside other function or in params part.

Ex:

```
// lib/operator.mew
fn mult(n: int) -> (m: int) -> int:
    fn (m: int) -> int:
        m * n
    end
end

fn mult_with_2(m: int) -> int:
    mult(2)(m)
end

fn apply(m: int, n: int, f: (m: int, n: int) -> int) -> int:
    f(m, n)
end
```

## Type

### Primary type

- int, int8, int16, int32, int64
- uint, unit8, uint16, uint32, uint64
- bool
- float32, float64

### Kernel compound type

- string

### Array

Type of array start `[]` and its type next.

Ex:

`[]int`

### Map

Type of map include type of key inside `[]` and type of value next to it.

Ex:

`[string]int`

## Operator

### Pipe operator

```
[1, 2, 3]
|> Enum.map(fn i: i * 2 end)
|> Enum.filter(fn i: i <= 5 end)
```

### Range operator

```
assert 1..3 == [1, 2, 3] // True
```

## Array

To get a element of array at position `i`:

```
arr = [1, 2, 3, 4, 5, 6]
assert arr[2] == 3 // True
```

To get elements of array at multiple positions:

```
assert arr[[2, 4]] == [3, 5] // True
```

To assign element to multiple positions:

```
arr = arr[1..3 | [20, 30, 40]] 
assert arr == [1, 20, 30, 40, 5, 6] // True
```

Append element:

```
arr = [arr | 7]
arr = [0 | arr]
assert arr == [0, 1, 2, 3, 4, 5, 6, 7] // True
```

## Map

To get a value from key:

```
map = {"cat": "mew", "dog": "goog"}
assert map["cat"] == "mew" // True
```

To get values from multiple keys:

```
assert map[["cat", "dog"]] == ["mew", "goog"] // True
```

Return default value:

```
assert map["mouse", "chip"] == "chip" // True
```

Update map:

```
map = {map | "mouse": "chip"}
assert map == {"cat": "meow", "dog": "goog", "mouse": "chip"} // True
```

## Pattern matching

```
map = {"cat": "meow", "dog": "goog"}

{"cat": cat_sound} = map
assert cat_sound == "meow" // True
```

## Reference counting

Not defined yet.

## Generic

Not defined yet.

## Bridge

Not defined yet.

## Port

Not defined yet.

## Config

Not defined yet.

## Actor Model

Not defined yet.