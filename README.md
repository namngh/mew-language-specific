# Mew Language Specific

Authors: Nguyễn Hoàng Nam

Inspiration: Elixir

Status: Draft

## Module

Each file is a module with the name generated by compiler following the rule:

- Combine the relative path file
- Name of directory write in camel case
- Seperate by dot

Ex:

```
config.mew
lib
|_ controllers
  |_ customer_controller.mew
```

Then the name of module in file customer_controller.mew is `Controllers.CustomerController`.

## Function

### Named Function

Named Function much define inside module so that it can be called by their module. Named Function
must has name and at least one arm.

Syntax:

```text
fn <<function_name>>
    (<<param>>: <<type>>, <<param>>: <<type>>) -> <<type>> gaurd <<condition>>:
        <<body>>

    (<<param>>: <<type>>) -> <<type>>:
        <<body>>
end
```

Ex:

```
// lib/utils/validation.mew
fn min_age(value: Int) -> Bool:
    value >= 18
end

fn max_age(value: Int) -> Bool:
    value < 100
end

fn validate_age
    (value: Int) -> Bool:
        min_age(value) && max_age(value)

    _ -> Bool:
        False
end
```

```
// lib/controllers/customer_controller.mew
fn put(conn: HTTP.Connection, _) -> (Ok | Error, any):
    conn
    |> Map.get("body", {})
    |> Map.get("age")
    |> Utils.Validation.validate_age()
    |> case:
        True: (Ok, {"success": True})
        _: (Ok, {"success": False})
    end
end
```

### Anonymous Function

Anonymous Function is a function without name. Anonymous Function works like other expression. Anonymous Function
must has at least one arm.

Syntax:

```
fn
    (<<param_1>>: <<param_1_type>>, <<param_2>>: <<param_2_type>>) -> <<first_return_type>> gaurd <<condition>>:
        <<first_body>>

    (<<param_3>>: <<param_3_type>>) -> <<second_return_type>>:
        <<second_body>>
end
```

Ex:

```
// Use Anonymous Function in return of other function
fn mult(n: Int) -> (Int) -> Int:
    fn (m: Int) -> Int:
        m * n
    end
end

// Use Annonymous Function as parameter of other function
fn apply(m: Int, n: Int, f: (Int, Int) -> Int) -> Int:
    f(m, n)
end
```

## Type

- Bit, Byte
- Int, Int8, Int16, Int32, Int64
- Uint, Uint8, Uint16, Uint32, Uint64
- Bool
- Float32, Float64
- String
- Array<Int>
- Map<String, Int>
- (Int, String)
- Result, None

### Atom

All uppercase identifier is Atom such as Module name, Type name, Struct field name.

Ex:

`True` is an Atom and has type `Bool`
`False` is an Atom and has type `Bool`
`Ok` is an Atom and has type `Result`
`Error` is an Atom and has type `Result`
`None` is an Atome and has type `None`

### Struct

Struct is a special map that validate type for each field. Field name in struct
is a Atom

Syntax:

```
struct RGB:
    R: int8,
    G: int8,
    B: int8
end
```

Ex:

```
red = RGB{R: 255, G: 0, B: 0}
red.R

remove_red = fn 
    (RGB{R: r} = color: RGB) -> RGB gaurd r > 0: RGB{color | R: 0}
    (color: RGB) -> RGB: color
end
```

### Enum

Enum is a special struct that value is generate at compile type.

Syntax:

```text
enum Week:
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
end

today = Week.Sunday

is_sunday = today
|> case:
    Week.Sunday: True
    _: False
end
```

### Tuple

Ex:

```text
(Ok, true)
```

### Type

Not supported yet.

## Operator

### Pipe operator

```
[1, 2, 3]
|> Enum.map(fn i: i * 2 end)
|> Enum.filter(fn i: i <= 5 end)
```

### Range operator

```
assert 1..3 == [1, 2, 3] // True
```

## Array

To get a element of array at position `i`:

```
arr = [1, 2, 3, 4, 5, 6]
assert arr[2] == 3 // True
```

To get elements of array at multiple positions:

```
assert arr[[2, 4]] == [3, 5] // True
```

To assign element to multiple positions:

```
arr = arr[1..3 | [20, 30, 40]] 
assert arr == [1, 20, 30, 40, 5, 6] // True
```

Append element:

```
arr = [arr | 7]
arr = [0 | arr]
assert arr == [0, 1, 2, 3, 4, 5, 6, 7] // True
```

## Map

To get a value from key:

```
map = {"cat": "mew", "dog": "goog"}
assert map["cat"] == "mew" // True
```

To get values from multiple keys:

```
assert map[["cat", "dog"]] == ["mew", "goog"] // True
```

Return default value:

```
assert map["mouse", "chip"] == "chip" // True
```

Update map:

```
map = {map | "mouse": "chip"}
assert map == {"cat": "meow", "dog": "goog", "mouse": "chip"} // True
```

## Control Flow

### Case

Ex:

```
case week:
    Week.sunday: "Weekend"
    Week.saturday: "Weekend"
    _: "Working day"
end
```

### Cond

Ex:

```
cond:
    age < 0: (Error, "Negative Age")
    age < 18 and not has_guardian: (Error, "Missing Guardian")
    _: (Ok, None)
end
```

## Pattern matching

```
map = {"cat": "meow", "dog": "goog"}

{"cat": cat_sound} = map
assert cat_sound == "meow" // True
```

## Byte code

## Reference counting

Not defined yet.

## Generic

Not defined yet.

## Bridge

Not defined yet.

## Port

Not defined yet.

## Config

Not defined yet.

## Actor Model

Not defined yet.